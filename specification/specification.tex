\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}

\usepackage{float}
\usepackage{syntax}
\usepackage{pifont}% http://ctan.org/pkg/pifont
\usepackage{paralist}
\usepackage{amsmath}
\usepackage{multicol}
\usepackage{color}


\setlength{\columnseprule}{1pt} %Separator ruler width
\def\columnseprulecolor{\color{blue}} %Separator ruler colour


\title{NGLess Specification}

\begin{document}

\maketitle

NGLess is a, imperative, domain specific language that infers variable types from context and is presented in a precise manner in the following document.

\section{Basic Characteristics}

\subsection{Data Types}
\label{sec:datatypes}

There are 4 (four) basic data types that can be instantiated in NGLess: Integers, chains of characters (String), Booleans (Bool) and Symbols.

\begin{itemize}
\item[$\ast$] \textbf{Integer} can hold any number, no matter how big.
\item[$\ast$] \textbf{String} is a chain of Unicode characters.
\item[$\ast$] \textbf{Bool} is an enumeration that can be either True or False.
\item[$\ast$] \textbf{Symbol} represents a tag that may have different meaning in other contexts.
\end{itemize}

\noindent
There are other data types, that are related to the biological context, but they can not be directly created. They are:

\begin{itemize}
\item[$\ast$] \textbf{ReadSet} keeps information about a data set.
\item[$\ast$] \textbf{ShortRead} is a read of a given data set.
\item[$\ast$] \textbf{MappedReadSet} keeps information about the map.
\item[$\ast$] \textbf{AnnotatedSet} stores annotation results.
\item[$\ast$] \textbf{Void} keeps no information.
\end{itemize}

In addition, is supported the composite type \textbf{List of X} where \textbf{X} is a basic type. All elements in \textbf{List} must have the same type. Lists are built with square brackets (e.g., \textbf{[1,2,3]}, a list of three integers).

The data types supported by each operator are indicated in the expression definition (§~\ref{sec:expr}).

\subsection{Name manipulation}

The names (§~\ref{sec:names}) correspond to constants and variables. In the following topics the term entity is used to designate them.

\subsubsection{Name space and identifiers visibility}

The name space is global and unique and for that reason a name used to designate an entity, on a given context, cannot be used to designate any other.

Identifiers are always visible. In particular, a redefined identifier on a lower context will modify it at a upper context.

\subsubsection{Validate variables}

The global entities (at the higher context), exist during the whole execution of the program. The variables, local to a block, exist only during his execution.


\subsection{Auto comprehension}
A function that receives a the data type \textbf{A} and returns \textbf{B} (A $\rightarrow$ * $\rightarrow$ B) can be automatically used as receiving a \textbf{List of A} and returning a \textbf{List of B} (i.e [A] $\rightarrow$ * $\rightarrow$ [B]).

\begin{verbatim}
in = fastq(["in1.fq", "in2.fq"])
\end{verbatim}

In the previous example, function fastq receives a \textbf{List of String} and returns a \textbf{List of ReadSet}.

\section{Lexical Conventions}

For each of the lexical elements (tokens), is considered the biggest sequence of characters existent that constitutes a valid lexical element.

\subsection{Line structure}

A program is divided into logical lines and one instruction cannot occupy more than one line, except if the instruction explicitly allows for a line change, for example the if condition.

\subsubsection{Physical lines}

A Physical line may have any size. The termination of a line (eol) does not depend on the operating system and must equally work in UNIX, MAC OS and Windows. The \textbf{line feed} (U+000A, \textbf{\textbackslash n}) and \textbf{carriage return} (U+000D, \textbf{\textbackslash r}) are both accepted as Physical line (eol) terminators.

\subsubsection{White characters}
\label{sec:white}

Are considered white characters those that, even though are used to separate lexical elements, do not represent one. 

Is considered white characters the Unicode character space \textbf{U+0020} (White Space, ' '). The character tabulation, \textbf{U+0009} (HT, \textbackslash t), cannot be used in NGLess as a white character.

The mentioned character, even though is white, has special meaning if appears at the beginning of a logical line. Similarly, the characters of line change (eol) also have special meaning in indentation (§~\ref{sec:indentation}) and comments (§~\ref{sec:comments}).

\subsubsection{White lines}

A logical line that only contains white characters and comments is ignored, not being generated any lexical element neither changing the indentation.

\subsubsection{Indentation}
\label{sec:indentation}

As previously mentioned in §~\ref{sec:white}, the character space is not considered white when in the beginning of a logical line.

The total number of white spaces until the first non-white character defines the level of indentation of the block. Each block must have the same level of indentation and it should be a multiple of 4.

Even though the levels of indentation might be different, the meaning can be the same:

\begin{multicols}{3}
\scriptsize
\begin{verbatim}
1. ngless "0.0"
2. in = fastq('sample.fq')
3. preprocess(in) using |read|:
4.    read = read[3:]
5.    if len(read) < 20:
6.        discard
7. m = map(in,reference='ce10')
\end{verbatim}
\normalsize
a. Correct indentation.
\columnbreak %Column break point
\scriptsize

\begin{verbatim}
1. ngless "0.0"
2. in = fastq('sample.fq')
3. preprocess(in) using |read|:
4.  read = read[3:]
5.  if len(read) < 20:
6.       discard
7. m = map(in,reference='ce10')
\end{verbatim}
\normalsize
b. Correct indentation.

\columnbreak %Column break point
\scriptsize
\begin{verbatim}
1. ngless "0.0"
2. in = fastq('sample.fq')
3.   preprocess(in) using |read|:
4. read = read[3:]
5. if len(read) < 20:
6.     discard
7. m = map(in,reference='ce10')
\end{verbatim}
\normalsize
c. Incorrect indentation.

\end{multicols}


Examples \textbf{a)} and \textbf{b)} are correct has both have an increasing indentation level and all instructions that are at the same level are consistent with the context. At example \textbf{c)}, the instruction with the \textbf{'preprocess'} function (Line 3) has two indentation errors:
\begin{itemize}
\item Indentation level higher than the one at the current context.
\item The provided block has lower indentation level and should have higher.
\end{itemize}

\subsection{Comments}
\label{sec:comments}
The comments work as separators of lexical elements. There are two kinds of comments:

\begin{description}
\item[Single-line] Start with \textbf{\#} or \textbf{//} (as long as the sequence does not belong to a chain of characters) and end at the line termination.
\item[Multi-line] Start with \textbf{/*} and terminates with \textbf{*/} (if the sequence does not belong to a chain of characters). Cannot be nested.
\end{description}


\subsection{Key Words}

The following words are reserved and do not constitute identifiers: 
\begin{center}
\textbf{if}, \textbf{else}, \textbf{ngless}, \textbf{len}, \textbf{discard}, \textbf{continue}, \textbf{using}
\end{center}
\subsection{Operators}

Are considered operators the following lexical elements:
\begin{center}
    \textbf{= + - * [ ] != == <= < >= >}
\end{center}

\subsection{Delimiters and Terminators}

The following lexical elements are considered delimiters/terminators:
\begin{center}
    \textbf{, : ( )}
\end{center}    


\subsection{Identifiers (names)}
\label{sec:names}

Are initiated by a letter (uppercase or lowercase) or by a '\_' (underscore). The first character can be followed by 0 (zero) or more letters, digits and underscores. The number of characters that constitute an identifier is unlimited and two names are distinct if there is a transformation of uppercase to lowercase, or vice versa, of at least one character.

\subsection{Literals}
\label{sec:literals}

Are notations for constant values of data types provided by NGLess.

\subsubsection{Integers}

An integer literal is a non rational number non negative (can be negative by the application of the unary operator (-) to a positive literal).

An integer literal in decimal is constituted by a sequence of 1 (one) or more digits (from 0 to 9). An integer literal in hexadecimal starts with the sequence \textbf{0x}, followed by one or more digits from 0 to 9, a to f or A to F.

There is an unlimited size representation to a integer.

\subsubsection{Chain of characters (string)}

A string can start with either a single quote\textbf{(U+0027,''')} or a quote \textbf{(U+0022, '"')} and end with the same character. They can contain any number of characters.

Special sequences are initiated by a \textbackslash. They can be represented by the characters \textbf{LF} and \textbf{CR} (\textbackslash n and \textbackslash r respectively), quotation marks (\textbackslash ') or slash (\textbackslash \textbackslash).

\subsubsection{Boolean}

A boolean literal can be represented as word \textbf{True} or \textbf{False}, with the first letter in upper or lower case.

\subsubsection{Symbol}

The representation is a token involved in curly brackets (\textbf{\{\}}). (e.g., \{CDS\} or \{gene\}). Symbols have specific meaning to functions (§~\ref{sec:functions}) as they allow to parametrise them.

\subsection{Complex data type format}

This data types result always from function invocations and cannot be created directly.

\subsubsection{ReadSet}
A ReadSet is a file in fastQ format. It has 1 or more \textbf{ShortRead}.

\subsubsection{ShortRead}
A ShortRead is each read of a \textbf{ReadSet} with the following structure:

\begin{grammar}
<read>    ::= `@'<seqname>`\textbackslash n'<seq>`\textbackslash n'+`\textbackslash n'<qual>`\textbackslash n'

<seqname> ::= String

<seq>     ::= String

<qual>    ::= [!-~]+

\end{grammar}

\noindent
The <qual> represents the quality of the read and has a range of values from 33 to 126.

\subsubsection{MappedReadSet}
MappedReadSet follows the Sequence Alignment/Map(SAM) format. The SAM Format allows to store sequence data in a series of tab delimited columns.

The SAM file is divided into two sections, the header and the alignment. The first contains information of the entire file and additional alignment information. The latter contains the information for each sequence about the alignment. 

Each line in the alignment section has 11 mandatory fields. In the following table is represented each field and his type.

\begin{table}[H]
    \center
    \begin{tabular}{llc}
    \hline
    Column & Field              & Type            \\ 
    \hline
    1 & QNAME   & String  \\
    2 & FLAG    & Integer \\
    3 & RNAME   & String  \\    
    4 & POS     & Integer \\
    5 & MAPQ    & Integer \\
    6 & CIGAR   & String  \\
    7 & RNEXT   & String  \\    
    8 & PNEXT   & Integer \\
    9 & TLEN    & Integer \\
    10 & SEQ    & String  \\
    11 & QUAL   & String  \\
    \end{tabular}
\end{table}

\subsubsection{AnnotatedSet}
A AnnotatedSet stores the result of annotating a given MappedReadSet. It follows a tab delimited structure and his represented next:

\begin{table}[H]
    \center
    \begin{tabular}{cll}
    \hline
    Column & Field & Type   \\ 
    \hline
    1 & Id      & String    \\
    2 & Features & List of Symbol \\
    3 & Counts   & Integer   \\    
    4 & Strand  & String    \\
    \end{tabular}
\end{table}

\section{Grammar}

The language grammar can be resumed by the rules described next. Consider that:
\begin{itemize}
    \item elements in fix type are called literals.
    \item optional items are enclosed in square brackets (i.e [<item-x>]).
    \item alternative elements are separated by a vertical bar (`|').
    \item items repeating 0 or more times are suffixed with an asterisk ('*').
    \item items repeating 1 or more times are suffixed with a plus ('+'). 
\end{itemize}

\begin{grammar}

<script>  ::= <version> <body>

<version> ::= `ngless' <literal-string>

<body>    ::= <instructions>

<block>   ::= <indentation> <instructions>

<instructions> ::= *<expr>

<expr> ::=   `continue' | `discard'
\alt <conditional>
\alt <iteration>
\alt <assignment>
\alt <funccall>
\alt <inner-expr>

<inner-expr> ::= <binary-op>
\alt <base-expr>
\alt <index-expr>
\alt <list-expr>

<base-expr>  ::= <pexpr>
\alt <literal>
\alt <unary-op>
\alt <variable>

<variable> ::= <word-req> *<word-opt>

<word-req> ::= {letter} | `\_'

<word-opt> ::= <word-req> | {digit}

<pexpr> ::= `(' <expr> `)'

<conditional> ::= `if' <expr> `:' <block> "[" `else' `:' <block> "]"

<iteration> ::= `preprocess' `('<expr>`)' `using' `|' <variable> `|' `:' <block>

<assignment> ::= <variable> `=' <expr>

<funccall>  ::= <func-name> `(' <expr> "*"<opt-args> `)'

<opt-args> ::= `,' <opt-arg>

<opt-arg>  ::= <variable> `=' <expr>

<list-expr>  ::= `[' `]' | `[' <inner-expr> "*"<inner-expr-opt> `]'

<inner-expr-opt> ::= `,' <ìnner-expr>

<index-expr> ::= <base-expr> <index-one>
\alt <base-expr> <index-two>

<index-two>  ::= `[' "[" <expr> "]" `:' "[" <expr> "]" `]'

<index-one>  ::= `[' <expr> `]'

<binary-op> ::= <base-expr> <bin-ops> <expr>

<unary-op> ::= <len-op>
\alt <unary-minus>

<unary-minus> ::= `-' <base-expr>

<len-op> ::= `len' <pexpr>

<indentation> ::= <literal-int>

<bin-ops> ::= `!=' | `==' | `<=' | `<' | `>=' | `>' | `+' | `*'

<func-name>   ::= `fastq' | `substrim' | `preprocess' | `map' | `count' | `unique' | `write' | `print' | `annotate'

<literal> ::= <literal-int>
\alt <literal-bool>
\alt <literal-string>
\alt <literal-symbol>

<literal-string> ::= String

<literal-symbol> ::= Symbol

<literal-int> ::= Integer

<literal-bool> ::= Boolean

\end{grammar}

The precedence of binary and unary operators are described in detail at section §~\ref{sec:expr}. Also, the values that the literals can take are defined in §~\ref{sec:literals}

\subsection{Left value}

The elements of an expression (operators) that can be used as a left-value are individually identified in section §~\ref{sec:expr}. 

\subsection{Script}

Is designated by script the file that contain all the code to run on NGLess. All scripts must be in \textbf{UTF-8} format.


\subsection{Variables and constants}

\subsubsection{Initialization}

Is performed with a value that follows the operator \textbf{=} ("equal"): integer (an Integer expression), string (a String expression), boolean (a Bool expression) and a symbol (a Symbol expression). Examples:

\begin{table}[H]
\center
    \begin{tabular}{lll}
    Integer & $\Longrightarrow$ & i = 2 \\
    String  & $\Longrightarrow$ & s = 'hey' \\
    Boolean & $\Longrightarrow$ & b = True \\
    Symbol  & $\Longrightarrow$ & s = \{gene\} \\
    \end{tabular}
\end{table}

To associate a variable with an array of expressions, it's required to start with the \textbf{[} operator and terminate with \textbf{]}. The expression should have the same type. Examples:\\

\begin{table}[H]
\center
    \begin{tabular}{lll}
    List of symbols & $\Longrightarrow$ & ls = [ \{gene\}, \{CDS\} ] \\
    List of strings & $\Longrightarrow$ & ls = [ `fp1', `fp2' ] \\
    \end{tabular}
\end{table}


\subsubsection{Constants}

The language allows for the definition of constant identifiers, preventing it of being used in operations that modify it's value. All characters in the identifier must be in upper case. Examples:


\begin{table}[H]
\center
    \begin{tabular}{lll}
    Constant integer & $\Longrightarrow$ & CI = 2 \\
    Constant string  & $\Longrightarrow$ & CS = 'hey' \\
    Constant boolean & $\Longrightarrow$ & CB = True \\
    Constant symbol  & $\Longrightarrow$ & CS = \{gene\} \\
    \end{tabular}
\end{table}


\section{Functions}

A function allows to execute predefined code to a given set of parameters, that are provided by argument.

With NGLess is not possible to define new functions. Nonetheless, a big variety of functions is provided and are described in §~\ref{sec:functions}.

\subsection{Invocation}
\label{sec:invoke}
A function can only be invoked by the use of an identifier that refers to one of the provided functions. After the identifier, the delimiter \textbf{(} is opened to refer to the start of the arguments and ended with the delimiter \textbf{)}.

Functions have a single positional parameter and all other must be provided by name. Example:

\begin{verbatim}
    result = f(arg, arg1=2)
\end{verbatim}

The argument \textbf{arg} can be any data type (§~\ref{sec:datatypes}) as for \textbf{arg1} it is an expression that evaluates either to a string, integer, bool or a symbol. The variable \textbf{result} will store a new data type that is consequence of executing the function \textbf{f}.

In most cases, all arguments are passed by value and no modification is made by the execution of a given function. In particular, there is one exception (pre\-process) and is detailed in §~\ref{sec:specin}.

\subsection{Parametrize functions}
\label{sec:optargs}

To parametrize functions, arguments must be passed by name. They are optional as all functions have default values, in case one is not provided. It works as a variable assignment but reflects only to the function. 

It is not possible to pass arguments by name to a function that has no use to them. The names and possible values must be followed and are detailed in §~\ref{sec:functions}.

\subsection{Pure functions}
\label{sec:purefunctions}

The result of calling a pure function must be assigned to another variable. At §~\ref{sec:functions} is indicated which function are pure.

\subsection{Special invocation}
\label{sec:specin}

Instead of multiple parameters, there is the case where a function takes a single positional parameter and a block. The block is a closure that is passed to the function and the parameter is passed by reference, which means that the variable provided will be modified. 

The block is passed with the \textbf{using} keyword. All instructions in the block must have the same indentation, using \textbf{white space (U+0020, ' ')}. Example:

\begin{verbatim}
f(all) using |i|:
    block
\end{verbatim}

It works as a for each, the contents of the variable \textbf{all} is traversed and kept in the variable \textbf{i} for each iteration. 

At the end the result of the function is assigned to the variable passed as argument, in this example \textbf{all}. The flow of the execution must continue even if the result is an empty data set.

\section{Instructions}

All instructions are executed in sequence.

\subsection{Conditional instruction}

If the expression evaluates to a \textbf{true} boolean then the block that follows the operator ':' is executed.

If the expression evaluates to a \textbf{false} boolean and is present the reserved word \textbf{else} and delimiter ':' , the else block is executed. If evaluates to \textbf{false} and the reserved word \textbf{else} is not present, nothing happens.

Case both the reserved word \textbf{if} and \textbf{else} are present, exactly one of the two blocks will be executed.

\subsection{Iteration instruction}
\label{sec:iter}

It is only possible to iterate the data type \textbf{ReadSet}. A ReadSet has zero or more \textbf{ShortRead}.

\begin{verbatim}
preprocess(reads) using |read|:
    block
\end{verbatim}

The variable \textbf{read} (ShortRead) contains each read of the variable \textbf{reads} (ReadSet). 

The variable passed to the 'preprocess', in this case \textbf{reads}, is passed by reference and so every modification to the variable \textbf{read} in the block modifies the variable \textbf{reads}. 

\subsection{Discard instruction}

Discard instruction can only be used inside an iteration instruction (§~\ref{sec:iter}). \\

Indicated by the reserved word \textbf{discard} (when executed, is the last instruction in the block) it removes the current ShortRead (being iterated) from the ReadSet and jumps for the next iteration.

\subsection{Continue instruction}

Discard instruction can only be used inside an iteration instruction (§~\ref{sec:iter}). \\

Indicated by the reserved word \textbf{continue} (when executed, is the last instruction in the block) it stops executing the block to an ShortRead (being iterated) from the ReadSet and jumps to the next iteration. 

\section{Expressions}
\label{sec:expr}

The expression are always evaluated from the left to the right, independent of the operator associativity.

The operators precedence is the same when in the same section, knowing that following sections represent less priority.

The following table is a resume of the possible operators and is grouped by decreasing precedence.

\begin{table}[H]
\center
    \begin{tabular}{l|l|l}
    primary         & () []     & non associative \\ 
    unary           & - len     & non associative \\
    multiplicative  & *         & left to right    \\
    aditive         & + -       & left to right   \\
    comparative     & < > >= <= & left to right   \\
    equality        & == !=     & left to right   \\
    atribution      & =         & right ro left   \\
    \end{tabular}
\end{table}

For example the following expressions would result in different values, due to precedence: 

\begin{itemize}
\item 5 + 5 * 2 = 15 
\item ((5 + 5) * 2) = 20
\end{itemize}

\subsection{Primary expressions}

\subsubsection{Identifiers}

One identifier can denote a variable or a constant.

A identifier is the most simple case of a left-value, this is an entity that can be used in the left of an attribution.

\subsubsection{Parentheses}

Expressions between parentheses, "(" and ")", has the same value as without them. This property allows for nested parentheses. \\

\noindent
One expression between parentheses can not be a left-value.

\subsubsection{Indexation}

Indexation expressions return the same data type. They can not be used as a left-value.

Can be used to access only one element or a range of elements. To access one element, is required a identifier followed by an expression between brackets. (e.g, x[10]).

To obtain a range, is required an identifier and two expressions separated by a ':' and between brackets. Example: \\

\begin{table}[H]
\center
    \begin{tabular}{lll}
    x[:] & $\Longrightarrow$ & returns from position 0 until length of variable x \\
    x[10:] & $\Longrightarrow$ & returns from position 10 util length of variable x \\
    x[:10] & $\Longrightarrow$ & returns from position 0 until 10 \\
    \end{tabular}
\end{table}


\noindent
Can only be applied to ShortReads.

\subsubsection{Invocation}

A function can only be invoked (§~\ref{sec:invoke}) through the use of a identifier that is specified at §~\ref{sec:functions}.

\subsubsection{Read}

The operation to look up for a given variable value can be performed by simply using it's name.

\subsection{Unary expressions}

The operator \textbf{(-)} returns the symmetric of it's Integer argument.

\noindent
The operator \textbf{len} returns the length of a ShortRead.


\subsection{Multiplicative expressions}

This operations are only applicable to Integer values, returning the value of the corresponding algebraic operation.


\subsection{Additive expressions}

This operations are only applicable to Integer values, as the previous.


\subsection{Comparative expressions}

This operations are only applicable to Integer values and returns a Bool. Therefore the return can either be true or false.

\subsection{Equality expressions}

This operations are only applicable to Integer values, as the previous.

\subsection{Attribution expressions}

The value of the expression in the right side of the operator '=' is saved in the variable, indicated by the left-value, at the left side of the attribution operator.\\

\noindent
To the same left-value can not be assigned right values with different types.

\section{Function Definition}
\label{sec:functions}

Here is provided the definition of all the available functions. To denote a List of a given data type is used \textbf{[ X ]} where \textbf{X} is the data type. (i.e [Symbol])

\subsection{Fastq}

Function to load, one or more, fastQ files. An example:
\begin{verbatim}
in = fastq('input.fq')
\end{verbatim}

\subsubsection*{Argument:}
String

\subsubsection*{Return:}
ReadSet

\subsubsection*{Arguments by value:}
none\\

\noindent
The String argument must be a valid file path and exist. An error is reported otherwise.\\

\noindent
The only compression method supported for the data sets is \textbf{gzip} (.gz). \\

\noindent
The encoding prediction is based on the lowest quality character of the fastQ file.\\

\noindent
When loading a data set, quality control is performed and statistics can be visualised in a graphical user interface (GUI).\\

\noindent
The simple statistics calculated are percentage of guanine and cytosine (\%GC), encoding prediction, number of sequences and minimum/maximum sequence length. The more complex statistics calculated are the mean, median, lower quartile and upper quartile for each position of the base pairs.

\subsection{Unique}

Function that receives a set of reads and returns a equal or smaller set of reads. Only retains a given number of copies for each read (if there are any duplicates). An example:
\begin{verbatim}
input = unique(input, max_copies=3)
\end{verbatim}

\subsubsection*{Argument:}
ReadSet

\subsubsection*{Return:}
ReadSet

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{l|l|c}
    \hline
    Name & Type & Required \\ \hline
    max\_copies  & Integer & \ding{56} \\
    \end{tabular}
\end{table}

\noindent
The optional argument \textbf{max_copies} allows to define the number of tolerated copies (default: 1). \\

\noindent
Is considered a copy: ShortReads with the same sequence regardless of quality and identifier.\\

\noindent
It's a pure function §~\ref{sec:purefunctions}.
\subsection{Preprocess}

This function executes the given block for each read in the ReadSet. Unless the read is \textbf{discarded}, it is transferred (after transformations) to the output. The output is assigned to the same name as the inputs. An example:


\begin{verbatim}
preprocess(inputs) using |read|:
    read = read[3:]
\end{verbatim}

\subsubsection*{Argument:}
ReadSet

\subsubsection*{Return:}
Void

\subsubsection*{Arguments by value:}
none\\

\noindent
This function also performs quality control on its output.


\subsection{Map}

The function map allows for a ReadSet to be mapped against a reference. An example:

\begin{verbatim}
mapped = map(input,reference='sacCer3')
\end{verbatim}

\subsubsection*{Argument:}
ReadSet

\subsubsection*{Return:}
MappedReadSet

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{l|l|c}
    \hline
    Name & Type & Required \\ \hline
    reference  & String & \ding{51} \\
    \end{tabular}
\end{table}

The argument \textbf{reference} must be either a path to a data set or the \textbf{name} of a provided data set by NGLess. The provided data sets of NGLess are:

\begin{table}[H]
\center
    \begin{tabular}{|l|l|l|}
    \hline
    Name      & Description                &    Assembly \\ \hline
    sacCer3   &  saccharomyces\_cerevisiae &    R64-1-1 \\ 
    ce10      &  caenorhabditis\_elegans   &    WBcel235 \\
    dm3       &  drosophila\_melanogaster  &    BDGP5 \\
    -         &  gallus\_gallus            &    Galgal4 \\
    canFam2   &  canis\_familiaris         &    CanFam3.1 \\
    rn4       &   rattus\_norvegicus       &    Rnor\_5.0 \\
    bosTau4   &    bos\_taurus             &    UMD3.1 \\
    mm10      & mus\_musculus              &    GRCm38 \\ 
    hg19      & homo\_sapiens              &    GRCh37 \\ \hline
\end{tabular}
\end{table}

If one of the previous data sets are chosen, the data sets will be downloaded (if they are not already locally). This data set contains the BWA index files and a gene annotation file.\\

\noindent
It's a pure function §~\ref{sec:purefunctions}.


\subsection{Annotate}

Given a file with aligned sequencing reads (ReadSet) and a list of genomic features (gff file), the function allows to annotate reads to each feature. An example:

\begin{verbatim}
annotated = annotate(mapped, strand={yes}, mode={union}, ambiguity={deny})
\end{verbatim}

\subsubsection*{Argument:}
MappedReadSet

\subsubsection*{Return:}
AnnotatedSet

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{llc}
    \hline
    Name        & Type              & Required            \\ 
    \hline
    gff         & String         & \ding{51}           \\
    features    & [ Symbol ]     & \ding{56}            \\
    mode        & Symbol         & \ding{56}          \\
    ambiguity   & Symbol         & \ding{56}            \\
    strand      & Symbol         & \ding{56}           \\
    \end{tabular}
\end{table}

\noindent
The \textbf{gff} argument is required, unless it was used a data set provided by NGLess on the map (map section). It must be a valid path to a annotation file.\\

\noindent
The argument \textbf{features} represents which features to keep, discarding everything else. If nothing is provided everything is considered to be important. The possible symbols are \textbf{\{gene\}}, \textbf{\{exon\}} and \textbf{\{cds\}}.\\

\noindent
\textbf{Mode} is a string that represents the mode to handle reads overlapping more than one feature. The possible values for \textbf{mode} are \textbf{\{union\}}, \textbf{\{intersection-strict\}} and \textbf{\{intersection-nonempty\}} (default: \{union\}). For each read position is obtained features that intersect it, which are called sets. The different modes are:
\begin{itemize}
\item \textbf{union} the union of all the sets.
\item \textbf{intersection-strict} the intersection of all the sets.
\item \textbf{intersection-nonempty} the intersection of all non-empty sets.
\end{itemize}

\noindent
The \textbf{ambiguity} argument allows to decide whether to count reads that overlap with more than one feature. The possible values are \{allow\} and \{deny\} (default: \{allow\}).\\

\noindent
Argument \textbf{strand} represents whether the data is from a strand-specific and the possible values can be \textbf{\{yes\}} or \textbf{\{no\}} (default: \{no\}). For \{no\}, a read is always overlapping with a feature independently of whether maps to the same or the opposite strand. For \{yes\}, the read has to be mapped to the same strand as the feature.


\subsection{Count}

Function that allows to filter the counts of features. Example:
\begin{verbatim}
counts = count(annotated, min=2)
\end{verbatim}

\subsubsection*{Argument:}
AnnotatedSet

\subsubsection*{Return:}
AnnotatedSet

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{llc}
    \hline
    Name        & Type              & Required            \\ 
    \hline
    counts         & [ Symbol ] & \ding{56}  \\
    min    & Integer     & \ding{56}            \\
    \end{tabular}
\end{table}

\noindent
The argument \textbf{counts} represents which features to keep, discarding everything else. The possible symbols are {gene}, {exon} and {cds}. If nothing is provided everything is considered to be important.\\

\noindent
\textbf{Min} defines the minimum amount of overlaps a given feature must have, at least, to be kept (default: 0).\\

\noindent
It's a pure function §~\ref{sec:purefunctions}.


\subsection{Substrim}

Given a read, returns another that is the biggest sub-sequence with a given minimum quality. Example:

\begin{verbatim}
read = substrim(read, min_quality=5)
\end{verbatim}

\subsubsection*{Argument:}
ShortRead

\subsubsection*{Return:}
ShortRead

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{llc}
    \hline
    Name        & Type              & Required            \\ 
    \hline
    min_quality         & Integer & \ding{56}  \\
    \end{tabular}
\end{table}

\noindent
\textbf{Min_quality} parameter defines the minimum quality accepted for the sub-sequence (default: 0). \\

\noindent
It's a pure function §~\ref{sec:purefunctions}.

\subsection{Write}

Write function allows to write a NGLessObject to Disk. Different Types of NGLessObject are manipulated in different manners.

\subsubsection{ReadSet}

\subsubsection*{Argument:}
ReadSet

\subsubsection*{Return:}
Void

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{llc}
    \hline
    Name        & Type              & Required            \\ 
    \hline
    ofile         & String & \ding{51}  \\
    \end{tabular}
\end{table}

The argument \textbf{ofile} is a file path to where the content is written.

\subsubsection{MappedReadSet}

\subsubsection*{Argument:}
MappedReadSet

\subsubsection*{Return:}
Void

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{llc}
    \hline
    Name        & Type              & Required            \\ 
    \hline
    ofile         & String & \ding{51}  \\
    format        & String & \ding{56}  \\
    \end{tabular}
\end{table}

\textbf{Format} can have value \textbf{\{bam\}} or \textbf{\{sam\}} (default: \{sam\}).

\subsubsection{AnnotatedSet}

\subsubsection*{Argument:}
AnnotatedSet

\subsubsection*{Return:}
Void

\subsubsection*{Arguments by value:}
\begin{table}[H]
    \begin{tabular}{llc}
    \hline
    Name        & Type              & Required            \\ 
    \hline
    ofile         & String & \ding{51}  \\
    format        & String & \ding{56}  \\
    verbose       & Symbol & \ding{56}  \\
    \end{tabular}
\end{table}

\textbf{Format} can have value \textbf{\{csv\}} or \textbf{\{tsv\}} (default: \{tsv\}).\\

\textbf{Verbose} allows to choose between writing a simplified or a verbose version of the results. Possible values are \textbf{\{yes\}} or \textbf{\{no\}} (default: \{no\}).\\

\noindent
If a list of \textbf{any} of the previous mentioned data types is provided, the \textbf{ofile} argument must use an \textbf{\{index\}} in the template name to differentiate between the files in the list. For example for a list with two elements:

\begin{verbatim}
ofile = "../samples/CountsResult{index}.txt"
\end{verbatim}

\noindent
would result in, \\
    
\textbf{    "../samples/CountsResult1.txt", "../samples/CountsResult2.txt"  }


\subsection{Print}

Print function allows to print a NGLessObject to IO. 

\subsubsection*{Argument:}
NGLessObject

\subsubsection*{Return:}
Void

\subsubsection*{Arguments by value:}
none


\section{Omissions and Errors}

Omissions and errors will be fixed in future versions of NGLess specification.

\end{document}
